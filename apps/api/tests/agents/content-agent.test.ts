import {
  describe,
  it,
  expect,
  beforeEach,
  jest,
  afterEach,
} from "@jest/globals";
import { ContentAgent } from "@neon/core-agents";
import {
  ContentGenerationInputSchema,
  ContentGenerationOutputSchema,
} from "@neon/core-agents/src/schemas/agent-schemas";
import { AgentPayload } from "@neon/core-agents";

// Mock OpenAI
jest.mock("openai", () => {
  return {
    __esModule: true,
    default: jest.fn().mockImplementation(() => ({
      chat: {
        completions: {
          create: jest.fn().mockResolvedValue({
            choices: [
              {
                message: {
                  content:
                    "This is a test content generated by AI for testing purposes.",
                },
              },
            ],
            usage: {
              total_tokens: 150,
            },
          }),
        },
      },
    })),
  };
});

// Mock BudgetTracker
jest.mock("@neon/utils", () => ({
  logger: {
    warn: jest.fn(),
    error: jest.fn(),
    info: jest.fn(),
  },
  BudgetTracker: {
    checkBudgetStatus: jest.fn().mockResolvedValue({
      canExecute: true,
      utilizationPercentage: 45.5,
    }),
    trackCost: jest.fn().mockResolvedValue(undefined),
  },
}));

describe("ContentAgent", () => {
  let contentAgent: ContentAgent;

  beforeEach(() => {
    contentAgent = new ContentAgent();
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe("Initialization", () => {
    it("should initialize with correct properties", () => {
      expect(contentAgent.id).toBe("content-agent");
      expect(contentAgent.name).toBe("ContentAgent");
      expect(contentAgent.type).toBe("content");
      expect(contentAgent.getCapabilities()).toEqual([
        "generate_content",
        "generate_blog",
        "generate_caption",
        "generate_post",
      ]);
    });

    it("should get agent status", async () => {
      const status = await contentAgent.getStatus();

      expect(status.id).toBe("content-agent");
      expect(status.name).toBe("ContentAgent");
      expect(status.type).toBe("content");
      expect(status.status).toBe("idle");
      expect(status.capabilities).toEqual([
        "generate_content",
        "generate_blog",
        "generate_caption",
        "generate_post",
      ]);
    });
  });

  describe("Input Validation", () => {
    it("should validate correct payload", () => {
      const validPayload: AgentPayload = {
        task: "generate_content",
        context: {
          type: "blog",
          topic: "AI Marketing",
          audience: "Digital marketers",
          tone: "professional",
        },
        priority: "medium",
      };

      expect(contentAgent.validatePayload(validPayload)).toBe(true);
    });

    it("should reject invalid payload", () => {
      const invalidPayload = {
        // Missing required fields
        context: {},
      } as AgentPayload;

      expect(contentAgent.validatePayload(invalidPayload)).toBe(false);
    });

    it("should validate input schema", () => {
      const validInput = {
        type: "blog" as const,
        topic: "AI Marketing Trends",
        audience: "Digital marketers",
        tone: "professional" as const,
        keywords: ["AI", "marketing", "automation"],
        length: "long" as const,
      };

      const result = ContentGenerationInputSchema.safeParse(validInput);
      expect(result.success).toBe(true);
    });

    it("should reject invalid input schema", () => {
      const invalidInput = {
        type: "invalid_type",
        topic: "", // Empty topic
        audience: "Digital marketers",
        tone: "professional",
      };

      const result = ContentGenerationInputSchema.safeParse(invalidInput);
      expect(result.success).toBe(false);
    });
  });

  describe("Content Generation", () => {
    const validContext = {
      type: "blog" as const,
      topic: "AI Marketing Automation",
      audience: "Small business owners",
      tone: "friendly" as const,
      keywords: ["automation", "AI", "marketing"],
      length: "medium" as const,
    };

    it("should generate blog content successfully", async () => {
      const payload: AgentPayload = {
        task: "generate_blog",
        context: validContext,
        priority: "medium",
      };

      const result = await contentAgent.execute(payload);

      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
      expect(result.data.content).toBeDefined();
      expect(result.data.suggestedTitle).toBeDefined();
      expect(result.data.readingTime).toBeGreaterThan(0);
      expect(result.data.seoScore).toBeGreaterThanOrEqual(0);
      expect(result.data.tokensUsed).toBeGreaterThan(0);
    });

    it("should generate social post content successfully", async () => {
      const payload: AgentPayload = {
        task: "generate_post",
        context: {
          ...validContext,
          type: "social_post",
          platform: "instagram",
        },
        priority: "medium",
      };

      const result = await contentAgent.execute(payload);

      expect(result.success).toBe(true);
      expect(result.data.content).toBeDefined();
      expect(result.data.hashtags).toBeDefined();
      expect(Array.isArray(result.data.hashtags)).toBe(true);
    });

    it("should generate email content successfully", async () => {
      const payload: AgentPayload = {
        task: "generate_content",
        context: {
          ...validContext,
          type: "email",
        },
        priority: "medium",
      };

      const result = await contentAgent.execute(payload);

      expect(result.success).toBe(true);
      expect(result.data.content).toContain("Subject:");
    });

    it("should generate caption content successfully", async () => {
      const payload: AgentPayload = {
        task: "generate_caption",
        context: {
          ...validContext,
          type: "caption",
          length: "short",
        },
        priority: "medium",
      };

      const result = await contentAgent.execute(payload);

      expect(result.success).toBe(true);
      expect(result.data.content).toBeDefined();
      expect(result.data.content.length).toBeLessThan(500); // Captions should be short
    });

    it("should generate copy content successfully", async () => {
      const payload: AgentPayload = {
        task: "generate_content",
        context: {
          ...validContext,
          type: "copy",
        },
        priority: "medium",
      };

      const result = await contentAgent.execute(payload);

      expect(result.success).toBe(true);
      expect(result.data.content).toBeDefined();
    });
  });

  describe("Error Handling", () => {
    it("should handle missing required context", async () => {
      const payload: AgentPayload = {
        task: "generate_content",
        context: {
          // Missing required fields
          type: "blog",
        },
        priority: "medium",
      };

      const result = await contentAgent.execute(payload);

      expect(result.success).toBe(false);
      expect(result.error).toContain("Missing required context");
    });

    it("should handle budget exceeded", async () => {
      // Mock budget check to return false
      const mockBudgetTracker = jest.requireMock("@neon/utils").BudgetTracker;
      mockBudgetTracker.checkBudgetStatus.mockResolvedValueOnce({
        canExecute: false,
        utilizationPercentage: 95.5,
      });

      const payload: AgentPayload = {
        task: "generate_content",
        context: {
          type: "blog",
          topic: "Test Topic",
          audience: "Test Audience",
          tone: "professional",
        },
        priority: "medium",
      };

      const result = await contentAgent.execute(payload);

      expect(result.success).toBe(false);
      expect(result.error).toContain("Budget exceeded");
    });

    it("should handle OpenAI API failure gracefully", async () => {
      // Mock OpenAI to throw an error
      const mockOpenAI = jest.requireMock("openai").default;
      const mockInstance = new mockOpenAI();
      mockInstance.chat.completions.create.mockRejectedValueOnce(
        new Error("OpenAI API Error"),
      );

      const payload: AgentPayload = {
        task: "generate_content",
        context: {
          type: "blog",
          topic: "Test Topic",
          audience: "Test Audience",
          tone: "professional",
        },
        priority: "medium",
      };

      const result = await contentAgent.execute(payload);

      // Should still succeed with fallback content
      expect(result.success).toBe(true);
      expect(result.data.content).toBeDefined();
    });

    it("should handle unknown task gracefully", async () => {
      const payload: AgentPayload = {
        task: "unknown_task",
        context: {
          type: "blog",
          topic: "Test Topic",
          audience: "Test Audience",
          tone: "professional",
        },
        priority: "medium",
      };

      const result = await contentAgent.execute(payload);

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });
  });

  describe("Output Validation", () => {
    it("should produce valid output schema", async () => {
      const payload: AgentPayload = {
        task: "generate_content",
        context: {
          type: "blog",
          topic: "Test Topic",
          audience: "Test Audience",
          tone: "professional",
          keywords: ["test", "automation"],
        },
        priority: "medium",
      };

      const result = await contentAgent.execute(payload);

      expect(result.success).toBe(true);

      // Validate output against schema
      const validation = ContentGenerationOutputSchema.safeParse(result.data);
      expect(validation.success).toBe(true);
    });
  });

  describe("Performance Tracking", () => {
    it("should track execution performance", async () => {
      const payload: AgentPayload = {
        task: "generate_content",
        context: {
          type: "blog",
          topic: "Test Topic",
          audience: "Test Audience",
          tone: "professional",
        },
        priority: "medium",
      };

      const result = await contentAgent.execute(payload);

      expect(result.success).toBe(true);
      expect(result.performance).toBeDefined();
      expect(typeof result.performance).toBe("number");
      expect(result.performance).toBeGreaterThan(0);
    });

    it("should get performance metrics", async () => {
      const metrics = await contentAgent.getPerformanceMetrics(7);
      // Metrics might be null if no data exists yet
      expect(metrics).toBeDefined();
    });
  });

  describe("Helper Functions", () => {
    it("should calculate SEO score correctly", async () => {
      const payload: AgentPayload = {
        task: "generate_content",
        context: {
          type: "blog",
          topic: "Test Topic",
          audience: "Test Audience",
          tone: "professional",
          keywords: ["test", "topic", "blog"],
        },
        priority: "medium",
      };

      const result = await contentAgent.execute(payload);

      expect(result.success).toBe(true);
      expect(result.data.seoScore).toBeDefined();
      expect(result.data.seoScore).toBeGreaterThanOrEqual(0);
      expect(result.data.seoScore).toBeLessThanOrEqual(100);
    });

    it("should calculate reading time correctly", async () => {
      const payload: AgentPayload = {
        task: "generate_blog",
        context: {
          type: "blog",
          topic: "Test Topic",
          audience: "Test Audience",
          tone: "professional",
          length: "long",
        },
        priority: "medium",
      };

      const result = await contentAgent.execute(payload);

      expect(result.success).toBe(true);
      expect(result.data.readingTime).toBeDefined();
      expect(result.data.readingTime).toBeGreaterThan(0);
    });

    it("should generate appropriate hashtags for social posts", async () => {
      const payload: AgentPayload = {
        task: "generate_post",
        context: {
          type: "social_post",
          topic: "AI Marketing",
          audience: "Digital marketers",
          tone: "professional",
          platform: "instagram",
        },
        priority: "medium",
      };

      const result = await contentAgent.execute(payload);

      expect(result.success).toBe(true);
      expect(result.data.hashtags).toBeDefined();
      expect(Array.isArray(result.data.hashtags)).toBe(true);
      expect(result.data.hashtags.length).toBeGreaterThan(0);
      expect(result.data.hashtags.length).toBeLessThanOrEqual(8);

      // Check hashtag format
      result.data.hashtags.forEach((hashtag: string) => {
        expect(hashtag).toMatch(/^#[a-zA-Z]/);
      });
    });
  });

  describe("Integration Tests", () => {
    it("should handle multiple sequential requests", async () => {
      const requests = [
        {
          task: "generate_content",
          context: {
            type: "blog" as const,
            topic: "AI in Healthcare",
            audience: "Healthcare professionals",
            tone: "professional" as const,
          },
        },
        {
          task: "generate_post",
          context: {
            type: "social_post" as const,
            topic: "Marketing Automation",
            audience: "Small businesses",
            tone: "friendly" as const,
            platform: "linkedin" as const,
          },
        },
        {
          task: "generate_caption",
          context: {
            type: "caption" as const,
            topic: "Product Launch",
            audience: "Tech enthusiasts",
            tone: "playful" as const,
          },
        },
      ];

      for (const request of requests) {
        const payload: AgentPayload = {
          ...request,
          priority: "medium",
        };

        const result = await contentAgent.execute(payload);
        expect(result.success).toBe(true);
        expect(result.data.content).toBeDefined();
      }
    });

    it("should maintain consistent quality across different content types", async () => {
      const contentTypes = [
        "blog",
        "social_post",
        "email",
        "caption",
        "copy",
      ] as const;
      const results = [];

      for (const type of contentTypes) {
        const payload: AgentPayload = {
          task: "generate_content",
          context: {
            type,
            topic: "Digital Transformation",
            audience: "Business executives",
            tone: "professional",
            keywords: ["digital", "transformation", "business"],
          },
          priority: "medium",
        };

        const result = await contentAgent.execute(payload);
        results.push(result);
      }

      // All should be successful
      results.forEach((result) => {
        expect(result.success).toBe(true);
        expect(result.data.content).toBeDefined();
        expect(result.data.content.length).toBeGreaterThan(0);
      });

      // Verify different content lengths based on type
      const blogResult = results[0]; // blog
      const captionResult = results[3]; // caption

      expect(blogResult.data.content.length).toBeGreaterThan(
        captionResult.data.content.length,
      );
    });
  });

  describe("Public API Methods", () => {
    it("should expose generatePost method", async () => {
      const context = {
        type: "social_post" as const,
        topic: "Test Topic",
        audience: "Test Audience",
        tone: "professional" as const,
      };

      const result = await contentAgent.generatePost(context);

      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
    });

    it("should expose generateBlog method", async () => {
      const context = {
        type: "blog" as const,
        topic: "Test Topic",
        audience: "Test Audience",
        tone: "professional" as const,
      };

      const result = await contentAgent.generateBlog(context);

      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
    });

    it("should expose generateCaption method", async () => {
      const context = {
        type: "caption" as const,
        topic: "Test Topic",
        audience: "Test Audience",
        tone: "professional" as const,
      };

      const result = await contentAgent.generateCaption(context);

      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
    });
  });
});
